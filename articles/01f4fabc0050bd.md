---
title: "Claude Code で Wassette (wasm で動かすMCPサーバー)を使ってみた"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [claude, mcp, webassembly, wasm, rust]
published: true
---

## はじめに

以下の記事を試して、Claude Code でも実行して、迷ったところメモです。

https://zenn.dev/mi2valley/articles/0779e5d3b32f06

## Wassette とは

[Wassette](https://github.com/microsoft/wassette/tree/main) は [WebAssembly](https://developer.mozilla.org/ja/docs/WebAssembly) コンポーネントを [MCP (Model Context Protocol)](https://modelcontextprotocol.io/) サーバーとして実行できるツールです。セキュリティを重視した設計で、サンドボックス環境でツールを実行できます。

Wassette の特徴:

- **セキュリティ**: Wasmtime のサンドボックス環境で安全に実行
- **移植性**: プラットフォーム非依存の Wasm コンポーネント
- **配布の容易さ**: OCI レジストリ経由での配布が可能

## 用語補足

記事を読み進める前に、主要な用語を整理しておきます。

### WebAssembly (Wasm)

ブラウザやサーバーで動作する低レベルなバイナリ形式の命令セットです。高速で安全な実行環境を提供します。

### MCP (Model Context Protocol)

AI アシスタントがツールやデータソースと連携するための標準プロトコルです。Claude などの AI モデルが外部リソースにアクセスする仕組みを提供します。

### WIT (WebAssembly Interface Types)

WebAssembly コンポーネント間のインターフェースを定義する言語です。関数のシグネチャやデータ型を `.wit` ファイルで記述します。

[WIT 仕様](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md)

### wkg (WebAssembly Package Manager)

WebAssembly コンポーネントのパッケージマネージャーです。

- `ghcr.io` ([GitHub Container Registry](https://docs.github.com/ja/packages/working-with-a-github-packages-registry/working-with-the-container-registry)) に Wasm コンポーネントを配置できます
- Docker でログインしていれば OCI レジストリとして `wkg` も同じ認証を使えます

[wkg GitHub](https://github.com/bytecodealliance/wasm-pkg-tools)

### Rust 開発ツール

- **cargo**: [Rust](https://www.rust-lang.org/ja) のビルドツール・パッケージマネージャー
- **rustup**: Rust のツールチェーン管理ツール
- **cargo component**: Wasm コンポーネントをビルドするための cargo サブコマンド

### bindings

WIT ファイルから各言語向けのコードを自動生成する仕組みです。Rust や Python などで Wasm コンポーネントを呼び出すためのインターフェースコードが生成されます。

### PAT (Personal Access Token)

GitHub のパッケージレジストリにアクセスするための認証トークンです。`wkg` で GitHub Container Registry にプッシュする際に必要です。
classic トークンを使用しました。

## 全体の手順

Wassette を使ったカスタムツール開発の流れは以下の通りです:

1. **コンポーネントを開発・ビルド** - Rust 等で Wasm コンポーネントを作成
2. **コンポーネントをパッケージとして管理** - GitHub Container Registry に配置
3. **Wassette 環境の構築** - MCP サーバーとして Wassette をセットアップ
4. **コンポーネントをロードして使用** - Wassette から呼び出し可能にする

## 1. コンポーネントを開発・ビルド

簡単な例として、文字数カウントツールの WIT 定義:

```wit
// wit/world.wit
package example:charcount;

interface count {
    count-chars: func(text: string) -> u32;
}
```

詳細な実装手順は以下の記事を参照してください:

https://zenn.dev/mi2valley/articles/0779e5d3b32f06

## 2. コンポーネントをパッケージとして管理

GitHub Container Registry に Wasm コンポーネントをプッシュします。

詳細は上記の Zenn 記事を参照してください。

## 3. Wassette 環境の構築

### 3-1. Wassette のインストール (Mac)

cargo や rust のエコシステムとは別に、Wasm ランタイムを組み込んだ wassette CLI を使います。
wassette の中で、Rust 等で作った component をロードして MCP サーバーのツールとして利用できるようにしています。

```bash
brew install wassette
```

### 3-2. Claude Code に MCP サーバーとして登録

以下のコマンドで Wassette を MCP サーバーとして Claude Code に登録します:

```bash
claude mcp add -- wassette wassette serve --stdio
```

このコマンドは Claude Code の設定ファイルに Wassette サーバーの設定を追加します。

Codex、Gemini CLI、Cursor 等でも利用可能です。

参考: https://github.com/microsoft/wassette/blob/main/docs/mcp-clients.md

### 3-3. 接続確認

```bash
$ claude mcp list
wassette: wassette serve --stdio - ✓ Connected
```

## 4. コンポーネントをロードして使用

### 4-1. コンポーネントのロード

Claude Code を起動して、以下のように Wasm コンポーネントをロードします:

```bash
claude
```

Claude Code 内で:

```
以下をロードして
oci://ghcr.io/<YOUR_GITHUB_USERNAME>/charcount:0.1.0
```

### 4-2. 使ってみた

Claude Code から文字数カウントツールを呼び出してみました。

#### 英語の文字列

```
次の文字列の文字数を教えて wassette で
"hello wasm mcp"
```

結果:

```
"hello wasm mcp"の文字数は14文字です。
```

#### 日本語の文字列

```
次の文字列の文字数を教えて wassette で
"ほげ"
```

結果:

```
"ほげ"の文字数は2文字です。
```

## トラブルシューティング

### コンポーネントのロード時のエラー

**認証エラーが発生する場合:**

```bash
docker login ghcr.io
```

で Docker の認証を確認してください。

**バージョンが見つからない場合:**

- OCI レジストリのタグが正しいか確認
- パッケージが public に設定されているか確認

### MCP サーバーの接続エラー

```bash
$ claude mcp list
```

で wassette が `✓ Connected` になっているか確認してください。

接続できない場合は、Claude Code を再起動してみてください。

## 感想

Wassette を使うことで以下のメリットを実感しました:

- **セキュリティ**: サンドボックス環境での実行により、安全にカスタムツールを追加できる
- **管理の容易さ**: GitHub Package として管理できるため、バージョン管理やチーム共有が簡単
- **開発体験**: Rust でツールを作成し、Claude から直接利用できるのは非常に便利

気が向いたら Python などの他の言語での実装も試してみたいと思います。
