---
title: "Rust x Actix Web x sqlx ã§ TODO API"
emoji: "ğŸ¦€"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [rust, api, actixweb, sqlite, sqlx]
published: true
---

# ã¯ã˜ã‚ã«

Rust ã§ TODO ã‚¢ãƒ—ãƒªã‚ˆã†ã® API ã‚’ä½œã‚Šã¾ã—ãŸã€‚

# ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰

https://github.com/optimisuke/hello-rust/tree/main/api

ã“ã“ã«ç½®ã„ã¦ã¾ã™ã€‚

# ä½¿ã£ãŸã‚‚ã®

https://actix.rs/

Web ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¨ã—ã¦ Actix Web ã‚’ä½¿ã„ã¾ã—ãŸã€‚
Rust API ã§æ¤œç´¢ã™ã‚‹ã¨ãã“ãã“æƒ…å ±å‡ºã¦ãã‚‹ã®ã§ã€ãã“ãã“æœ‰åãªã®ã‹ãªã¨ã„ã†å°è±¡ã§ã™ã€‚

https://github.com/launchbadge/sqlx

ã¾ã  DB å‘¨ã‚Šã¯ã€sqlx ã§ sqlite ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã¾ã™ã€‚

# ãƒã‚¤ãƒ³ãƒˆ

- sqlx ã®ã‚¯ã‚¨ãƒªã‚’ä½¿ã†ã¨ãã€NOT NULL ã«ãªã‚Šå¾—ã‚‹ã¨å‹ãŒæ›–æ˜§ã«ãªã®ã§ã€æ˜ç¤ºçš„ãª sql ã‚’æ›¸ã„ã¦è§£æ±ºã—ã¦ã¾ã™ã€‚select æ–‡ã«æ³¨ç›®ã§ã™ã€‚
- DB æ¥ç¶šãƒ—ãƒ¼ãƒ«ã‚‚ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚„ãƒœãƒ‡ã‚£ã®å€¤ã‚‚å¼•æ•°ã«æ›¸ãã®ã§ã‚·ãƒ³ãƒ—ãƒ«ã«è¦‹ãˆã¾ã™ã€‚
- ã¡ã‚ƒã‚“ã¨ CORS ç”¨ã®ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚‚ã‚ã‚Šã¾ã—ãŸã€‚ã¨ã‚Šã‚ãˆãšå…¨ç„¡è¦–ã§å¯¾å¿œã—ã¦ã¾ã™ã€‚

# ã‚³ãƒ¼ãƒ‰

ã“ã‚“ãªæ„Ÿã˜ã§ã™ã€‚

## Cargo.toml

```toml:Cargo.toml
[package]
name = "api"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4"
actix-cors = "0.6"
actix-rt = "2"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sqlx = { version = "0.6", features = [
    "runtime-actix-native-tls",
    "sqlite",
    "chrono",
] }
dotenv = "0.15"
uuid = { version = "1.1", features = ["v4"] }
```

## .env

```.env
DATABASE_URL=sqlite://todos.db
```

## sql

```sql:setup.sql
CREATE TABLE todos (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  completed BOOLEAN NOT NULL DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## main.rs

```rs:src/main.rs
use actix_cors::Cors;
use actix_web::{web, App, HttpResponse, HttpServer, Responder};
use serde::{Deserialize, Serialize};
use sqlx::SqlitePool;
use uuid::Uuid;

// Todo struct
#[derive(Serialize, Deserialize)]
struct Todo {
    id: String,
    title: String,
    completed: bool,
}

// Todoã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆç”¨
#[derive(Deserialize)]
struct CreateTodo {
    title: String,
}
// Updateã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆç”¨
#[derive(Deserialize)]
struct UpdateTodo {
    title: String,
    completed: bool,
}

// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã®è¨­å®š
async fn get_db_pool() -> SqlitePool {
    let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    SqlitePool::connect(&database_url).await.unwrap()
}

// Todoã‚’å…¨ã¦å–å¾—
async fn get_todos(pool: web::Data<SqlitePool>) -> impl Responder {
    let todos = sqlx::query_as!(
        Todo,
        r#"SELECT id as "id!", title as "title!", completed FROM todos"#
    )
    .fetch_all(pool.get_ref())
    .await
    .unwrap();

    HttpResponse::Ok().json(todos)
}

// æ–°ã—ã„Todoã‚’ä½œæˆ
async fn create_todo(
    pool: web::Data<SqlitePool>,
    todo_data: web::Json<CreateTodo>,
) -> impl Responder {
    let new_id = Uuid::new_v4().to_string();

    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ–°ã—ã„Todoã‚’æŒ¿å…¥
    sqlx::query!(
        "INSERT INTO todos (id, title, completed) VALUES (?, ?, ?)",
        new_id,
        todo_data.title,
        false,
    )
    .execute(pool.get_ref())
    .await
    .unwrap();

    // æ–°ã—ãä½œæˆã•ã‚ŒãŸTodoã‚’ä½œæˆã—ã¦è¿”ã™
    let new_todo = Todo {
        id: new_id.clone(),
        title: todo_data.title.clone(),
        completed: false,
    };

    // JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¨ã—ã¦æ–°ã—ã„Todoã‚’è¿”ã™
    HttpResponse::Created().json(new_todo)
}

// Todoã®æ›´æ–°å‡¦ç†
async fn update_todo(
    pool: web::Data<SqlitePool>,
    todo_id: web::Path<String>,
    todo_data: web::Json<UpdateTodo>,
) -> impl Responder {
    let id = todo_id.into_inner();
    sqlx::query!(
        "UPDATE todos SET title = ?, completed = ? WHERE id = ?",
        todo_data.title,
        todo_data.completed,
        id,
    )
    .execute(pool.get_ref())
    .await
    .unwrap();

    HttpResponse::Ok().body("Todo updated")
}

// Todoã®å‰Šé™¤å‡¦ç†
async fn delete_todo(pool: web::Data<SqlitePool>, todo_id: web::Path<String>) -> impl Responder {
    let id = todo_id.into_inner();
    sqlx::query!("DELETE FROM todos WHERE id = ?", id)
        .execute(pool.get_ref())
        .await
        .unwrap();

    HttpResponse::Ok().body("Todo deleted")
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    dotenv::dotenv().ok();
    let pool = get_db_pool().await;

    HttpServer::new(move || {
        App::new()
            .wrap(
                Cors::default()
                    .allow_any_origin() // å¿…è¦ã«å¿œã˜ã¦å¤‰æ›´
                    .allow_any_method()
                    .allow_any_header()
                    .max_age(3600),
            )
            .app_data(web::Data::new(pool.clone()))
            .route("/todos", web::get().to(get_todos))
            .route("/todos", web::post().to(create_todo))
            .route("/todos/{id}", web::put().to(update_todo))
            .route("/todos/{id}", web::delete().to(delete_todo))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
```

# æ‰‹é †

1. sql ã§ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆï¼ˆ`sqlite3 todos.db < setup.sql`ï¼‰
2. cargo ã§ runï¼ˆ`cargo run`ï¼‰
3. curl ç­‰ã§`127.0.0.1:8080`ã«ã‚¢ã‚¯ã‚»ã‚¹ç¢ºèª

# ãŠã‚ã‚Šã«

ä»–ã®è¨€èªã¨åŒã˜ã‚ˆã†ãªæ„Ÿã˜ã§ã‹ã‘ã¦ã‚¹ãƒˆãƒ¬ã‚¹å°‘ãªãã†ã§ã™ã€‚
ãã®ã†ã¡ ORM (Object Relational Mapper) ã‚’ä½¿ã£ã¦ã¿ãŸã„ã¨ã“ã‚ã§ã™ã€‚
