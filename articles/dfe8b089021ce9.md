---
title: "FastAPI の SQLAlchemy DB セッションを渡す仕組みを、yield と async with と Depends から理解する"
emoji: "🐍"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [fastapi, python, sqlalchemy]
published: true
---

## はじめに

FastAPI + SQLAlchemy の例を見ると、こんなコードが出てきます。

```python
async def get_db():
    async with SessionLocal() as session:
        yield session
```

試すとそれっぽく動くけど、

- なぜ `return session` じゃないのか
- なぜ Router で `Depends(get_db)` と書くのか

に答えようと思うと、一つ一つの要素をちゃんと理解しないとわかりません。

この記事では、この `get_db()` が **何をしている関数なのか**を
`async with`・`yield`・`Depends` の 3 点から整理します。

ゴールは **「この関数を自分の言葉で説明できるようになること」** です。

---

## 想定読者

- FastAPI + SQLAlchemy（Async）を使っている
- `get_db()` をサンプルからそのまま使っている
- でも、**なぜ `yield`？ なぜ `async with`？ なぜ `Depends(get_db)`？** が腑に落ちていない人

---

## 中心となるコード

```python
async def get_db() -> AsyncSession:
    async with SessionLocal() as session:
        yield session
```

---

## なぜ `async with SessionLocal()` を使うのか

`AsyncSession` は、1 リクエスト中の **作業単位**です。
コネクションそのものではありません。

```python
async with SessionLocal() as session:
```

これは、

- セッションを作り
- 処理が終わったら **必ず後始末する**

という構造です。

セッションを閉じ忘れると、コネクションがプールに戻らず、枯渇の原因になります。

👉 `async with` は
**後始末を忘れないための安全装置**です。

---

## なぜ `yield` を使うのか

```python
async def get_db():
    async with SessionLocal() as session:
        yield session
```

これは **async generator** です。

ポイントは：

- 関数が 1 回だけ呼ばれる
- `yield` で処理が一時停止する
- 後で **同じ関数の続きを再開できる**

FastAPI はこの性質を使います。

---

## `Depends(get_db)` が何をしているのか

`Depends(get_db)` は、これを引数として動かす関数にセッションを渡す仕組みです。いくつかの役割を同時に実施しています。

FastAPI はこれが引数に入っているエンドポイントに対して、

- （起動時ではなく）リクエスト開始時に get_db を実行
- エンドポイント実行
- リクエスト終了時に後始末

という流れを自動で組み立てます。

また、同じリクエスト内で何度 `Depends(get_db)` があっても、**セッションは 1 つだけ共有**されます。

## @router デコレータが何をしているのか

```python
@router.get("/items")
async def read_items(
    db: AsyncSession = Depends(get_db)
):
    ...
```

`@router.get` が付くことで、この関数は
**FastAPI が「呼び出し方を管理する関数」**になります。

FastAPI はリクエスト時に、内部で以下のようなことをします。

1. `get_db()` を呼び、async generator を得る
2. `await anext(generator)` を実行
   - `yield session` まで進み、`session` を取り出す
3. その `session` を `db` 引数に渡してエンドポイントを実行
4. エンドポイント終了後 **同じ generator をもう一度進める**
5. `yield` の後が実行され、`async with` を抜けてセッションが閉じる

重要なのは、 **同じ関数の「続き」を再開している** という点です。

---

## 動き

また、以下のように print や try/finally を追加して実行すると、

```python
async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        try:
            print("session start")
            yield session
            print("session stop")
        finally:
            print("session closing")
    print("session closed")
```

以下のような結果が得られます。

```
session start
INFO:     127.0.0.1:65067 - "GET /items HTTP/1.1" 200 OK
session stop
session closing
session closed
```

yield の後の部分がエンドポイント実行後に処理されていることがわかります。

---

## なぜ Depends(get_db) を Router に書くのか

DB セッションの開始と終了は**HTTP リクエストのライフサイクルと一致**します。

そのため、

- Router の次の層（Service 層等）には FastAPI を持ち込まず
- HTTP 層（Router）で宣言する

のが自然です。

---

## まとめ

- `async with`
  - セッションの後始末を保証する
- `yield`
  - 処理を途中で止め、後で続きを実行できるようにする
- `Depends`
  - リクエスト単位で **「準備 → 使用 → 後始末」** を組み立てる

`get_db()` は、
**FastAPI に DB セッションのライフサイクル管理をお願いすること**
です。

---

## おわりに

FastAPI + SQLAlchemy において DB セッション管理は魔法ではありません。
一つずつ、動きを確かめ理解を深めることで、デバッグ時にも役に立つと思います。

・・・偉そうに書きましたが、もし間違えていたら、コメントください 🙇
